1.  模板类的模板成员函数不支持默认模板参数
linux：
2.  "warning: integer constant is too large for 'long' type".
    long long ll = 960822775440                 ==> can use it on msvc
    ==> long long ll = 960822775440LL
    
2.  type/value mismatch at argument 1
        missing a argument of template
3.  file not recognized: Is a directory
        -L..\lib                                    ==> no space after -L
        -L 后面为绝对目录                            ==> 新版本可不是
4.  makefile flag 后面下一行\t 开头

5.  error: ‘value_type’ does not name a type
        tmp_test.cpp:17: note: (perhaps ‘typename base_class<T>::value_type’ was intended)
        模板类中不能是模板基类中内嵌类型                  == can use it on msvc
        不能使using base_class<T>::type;
        只能通过typedef base_class<T>::type type;
6.  关于接口导出  error 
       #ifdef  WIN32
         #ifdef __cplusplus 
           #define DLL_EXPORT_C_DECL extern "C" __declspec(dllexport)
           #define DLL_IMPORT_C_DECL extern "C" __declspec(dllimport)
           #define DLL_EXPORT_DECL extern __declspec(dllexport)
           #define DLL_IMPORT_DECL extern __declspec(dllimport)
           #define DLL_EXPORT_CLASS_DECL __declspec(dllexport)
           #define DLL_IMPORT_CLASS_DECL __declspec(dllimport)
         #else
           #define DLL_EXPORT_DECL __declspec(dllexport)
           #define DLL_IMPORT_DECL __declspec(dllimport)
         #endif
        #else
         #ifdef __cplusplus
           #define DLL_EXPORT_C_DECL extern "C"
           #define DLL_IMPORT_C_DECL extern "C"
           #define DLL_EXPORT_DECL extern
           #define DLL_IMPORT_DECL extern
           #define DLL_EXPORT_CLASS_DECL
           #define DLL_IMPORT_CLASS_DECL
         #else
           #define DLL_EXPORT_DECL extern
           #define DLL_IMPORT_DECL extern
         #endif
       #endif
   "something.h"中包括：
    #include "common.h"
    #ifdef SOME_EXPORTS
       #define SOME_CLASS DLL_EXPORT_CLASS_DECL
       #define SOME_API   DLL_EXPORT_DECL
    #else
       #define SOME_CLASS DLL_IMPORT_CLASS_DECL
       #define SOME_API   DLL_IMPORT_DECL
    #endif
    ////
    #ifdef _MSC_VER
        // Switching on Windows Memory leaks detection.
        #ifndef _CRTDBG_MAP_ALLOC
            #define _CRTDBG_MAP_ALLOC   
        #endif
        #include <stdlib.h>
        #include <crtdbg.h>
        #pragma warning(disable : 4996)
        #ifdef NCDB_EXPORTS
            #ifndef NCDB_API
                #define NCDB_API  __declspec (dllexport)
            #endif
        #elif NCDB_STATIC_IMPORT
            #ifndef NCDB_API
            #define NCDB_API
            #endif
        #else
            #ifndef NCDB_API
            #define NCDB_API  __declspec (dllimport) // 对于带有静态成员的class 引用
            #endif
        #endif
    #else // linux
        #ifndef NCDB_API
        #define NCDB_API
    #endif
    #endif

7.  __declspec(dllimport)
    API_DECLSPEC
    只在windows 到处带有静态成员变量的class时是必需的（windows）
    也就是说dll 工程__declspec(dllexport)
    引入工程        __declspec(dllimport)
8.  gcc  -fpic   -shared add.c  sub.c  -o libtiger.so
    export LD_LIBRARY_PATH=`pwd`:$LD_LIBRARY_PATH
9.  模板中使用类的内嵌类行需要template
    template<typename T>
    int ttv(){typename vector<T>::const_iterator item;return 0;}  // ok on windows, erro on linux
10.         
    index_rect::iterator<index_rect::column> cend = r.end_impl<index_rect::column>();
    for (index_rect::iterator<index_rect::column> item_l = r.begin_impl<index_rect::column>();
        //item_l != r.end_impl<index_rect::column>(); // error on linux, exist operator != in index_rect::iterator
        item_l != cend;
            ++item_l)
            
11. 函数模板不能成为模板的模板参数  => boost::bind 不能绑定函数模板， 可以func，class， template class

12.
    SGI http://www.sgi.com/tech/stl/download.html
    线说明文档由Austern编写，参见网址：http://www.sgi.com/tech/stl/
    about stl/boost
    http://stlchina.huhoo.net/twiki/bin/view.pl/Main/WebHome
13.
    diff –uN from-file to-file >to-file.patch
    patch –p0 < to-file.patch
    patch –RE –p0 < to-file.patch
    多个文件
    diff –uNr from-docu to-docu >to-docu.patch
    patch –p1 < to-docu.patch
    patch –R –p1 <to-docu.patch
    //out
    .rej  reject
    .orig   multi version
14 template 中 使用带有template 参数的template 中before type add typename， before template add template
15  long* p = new long[0];
    delete p;       will lead to unknow error
16. 
    //1
    基类中虚函数（非纯虚函数） ，如果创建实例是必须有实现
    class base
    {
    public:
        virtual void fun(int i);
        void virtual no_use() = 0;
    };
    class derive : public base
    {
        void fun(int v){return;}
        void virtual no_use(){};
    };
    base b;     // **创建base 类， 提示找不到fun实现
    derive d;   // **创建derive 类， 先创建base时提示找不到fun实现
    //2 纯虚函数可以没有实现
        class base
    {
    public:
        virtual void fun(int i) = 0;
        void virtual no_use() = 0;
    };
    class derive : public base
    {
    public：
        void fun(int v){return;}
        void virtual no_use(){};
    };
    //3 非虚函数可以没有实现， 只要不调用即可，但是不能达到多态
    class base
    {
    public:
        void fun(int i);
        void virtual no_use() = 0;
    };
    class de : public base
    {
    public:
        void fun(int v){return;}
        void virtual no_use(){};
    };
    需要使用dynamic_cast转换类型， 不会默认使用动态类型的函数， 即覆盖问题
    base *p = new de;  // de 为动态类型， base是静态类型
    (dynamic_cast<de*>(p))->fun(1);
    
    总结 非纯虚函数的虚函数必须有实现，否则基类和派生类不能创建
        普通成员函数可以没有实现， 但由于不能多态，使用指针时会调用静态类型的函数，所以也必须有实现， 除非使用dynamic_cast， 这样这个函数也不用声明。
        class base_report_value
        {
        public:    
            virtual void set_value(unsigned int v){};       // 因为基类不能实例化，所以也不会调到
            virtual void set_value(bool v){};
            virtual void putout(ostream& report) = 0;       // 不能实例化
        };
        template<typename T>
        class report_value : public base_report_value
        {
        public:
            report_value(int N = 1):_N(N){ _v = T();}
            void set_value(T v)
            {
                _v = v;
            }
            void putout(ostream& report)
            {
                report << setw(_N) << _v << ',';
            }
        private:
            T _v;
            unsigned _N;
        };
17.vector 基础问题
    resize   创建新元素
    reserve  只是分配空间，避免了从分配应该用这个
    追加vector
    s.l.insert(s.l.end(),l.begin(), l.end());
18.只特化模板类中的成员函数
    template<typename T>
    class report_value : public base_report_value
    {
    public:
        report_value(int N = 1):_N(N){ _v = T();}
        void set_value(T v)
        {
            _v = v;
        }
        void putout(ostream& report)
        {
            report << setw(_N) << _v << ',';
        }
    private:
        T _v;
        unsigned _N;
    };

    template<>
    void report_value<bool>::putout(ostream& report)
    {
        report << setw(_N) << (_v?'Y':'N') << ',';
    }
19.
    struct test_struct
    {
        const char* text;
        const float x;
        const float y;
    };
    test_struct test_case[] =
    {
    	{"name 1"				,50F, 100F},
        {"name 2"					,52F, 102F},
    };
    也可以
    test_struct test_case[] =
    {
    	"name 1"				,50F, 100F,
        "name 2"					,52F, 102F,
    };
    int total = ((int)(sizeof(test_case)/sizeof(test_case[0])));
    for (int i = 0; i < total; i++)
	{
    	center.x = test_case[i].x;
		center.y = test_case[i].y;
        char buf[300] = {0};
		sprintf(buf, "%s", test_case[i].text);
    }

20.一种assert 方式，失败后打印原因
    assert((address % m_alignment == 0) || 
        !"precondition violation: address must be a multiple of m_alignment");

21.初始化3个0
    std::vector<char> t(3, 0);
